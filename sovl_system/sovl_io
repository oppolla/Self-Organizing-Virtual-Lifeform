import json
import os
import sys

def load_jsonl(file_path, min_entries=10):
    """
    Load a JSONL file into a list of dictionaries with validation.
    
    Args:
        file_path (str): Path to the JSONL file.
        min_entries (int): Minimum number of valid entries required.
    
    Returns:
        list: List of dictionaries with 'prompt' and 'completion' keys.
    
    Raises:
        InsufficientDataError: If fewer than min_entries valid entries are loaded.
        SystemExit: If file is not found or other critical errors occur.
    """
    data = []
    error_log = []

    try:
        # Attempt to open and read the file
        with open(file_path, 'r', encoding="utf-8") as file:
            for line_number, line in enumerate(file, start=1):
                try:
                    entry = json.loads(line.strip())
                    # Validate the structure of each entry
                    if not isinstance(entry.get("prompt"), str) or not isinstance(entry.get("response"), str):
                        error_log.append(f"Line {line_number}: Missing or invalid 'prompt' or 'response'. Skipping.")
                        continue
                    # Append valid entry
                    data.append({"prompt": entry["prompt"], "completion": entry["response"]})
                except json.JSONDecodeError as e:
                    error_log.append(f"Line {line_number}: JSON decode error: {e}. Skipping.")
        
        # Print warnings if any
        if error_log:
            print("Warnings encountered during data loading:")
            for error in error_log:
                print(f"WARNING: {error}")
            # Optionally, write errors to a file
            with open("data_load_errors.log", "w", encoding="utf-8") as log_file:
                log_file.write("\n".join(error_log))
        
        # Check if the minimum threshold is met
        if len(data) < min_entries:
            print(f"ERROR: Loaded only {len(data)} valid entries from {file_path}. Minimum required: {min_entries}.")
            raise InsufficientDataError(f"Aborting: Insufficient valid data entries. Check 'data_load_errors.log' for details.")
    
    except FileNotFoundError:
        print(f"CRITICAL: File not found: {file_path}. Aborting process.")
        sys.exit(1)  # Exit the process cleanly with a failure status
    
    except Exception as e:
        print(f"CRITICAL: Unexpected error: {e}. Aborting process.")
        sys.exit(1)  # Exit the process cleanly with a failure status

    # Return validated data
    print(f"INFO: Data Validation: {len(data)} entries loaded successfully.")
    return data

def load_config(config_file="sovl_config.json", defaults=None):
    """
    Load a JSON config file, falling back to defaults if not found.
    
    Args:
        config_file (str): Path to the config file (default: "sovl_config.json").
        defaults (dict, optional): Default config values if file is missing.
    
    Returns:
        dict: Loaded or default configuration.
    """
    if defaults is None:
        defaults = {}
    try:
        with open(config_file, "r", encoding="utf-8") as f:
            config = json.load(f)
            # Merge defaults with loaded config (loaded takes precedence)
            return {**defaults, **config}
    except FileNotFoundError:
        print(f"Warning: Config file {config_file} not found, using defaults.")
        return defaults
    except json.JSONDecodeError as e:
        print(f"Warning: Invalid JSON in {config_file}: {e}, using defaults.")
        return defaults
    except Exception as e:
        print(f"Warning: Failed to load {config_file}: {e}, using defaults.")
        return defaults

def get_config_value(config, key, default=None):
    """
    Safely retrieve a nested value from a config dict using dot notation.
    
    Args:
        config (dict): Configuration dictionary.
        key (str): Dot-separated key (e.g., "controls_config.enable_error_listening").
        default: Value to return if key is not found.
    
    Returns:
        Value from config or default if not found.
    """
    keys = key.split(".")
    value = config
    try:
        for k in keys:
            value = value[k]
        return value
    except (KeyError, TypeError):
        return default

if __name__ == "__main__":
    # Quick test
    # Test load_jsonl
    with open("test.jsonl", "w", encoding="utf-8") as f:
        f.write('{"prompt": "test1", "response": "resp1"}\n')
        f.write('{"prompt": "test2", "response": "resp2"}\n')
    print("JSONL:", load_jsonl("test.jsonl", min_entries=1))
    os.remove("test.jsonl")

    # Test load_config
    config_defaults = {"quantization_mode": "int8", "enable_error_listening": True}
    with open("test_config.json", "w", encoding="utf-8") as f:
        json.dump({"quantization_mode": "int4"}, f)
    config = load_config("test_config.json", config_defaults)
    print("Config:", config)
    print("Nested value:", get_config_value({"a": {"b": 3}}, "a.b", 0))
    os.remove("test_config.json")
